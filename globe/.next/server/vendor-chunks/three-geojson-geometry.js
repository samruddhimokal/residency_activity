"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/three-geojson-geometry";
exports.ids = ["vendor-chunks/three-geojson-geometry"];
exports.modules = {

/***/ "(ssr)/./node_modules/three-geojson-geometry/dist/three-geojson-geometry.mjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/three-geojson-geometry/dist/three-geojson-geometry.mjs ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GeoJsonGeometry: () => (/* binding */ GeoJsonGeometry)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var earcut__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! earcut */ \"(ssr)/./node_modules/earcut/src/earcut.js\");\n/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-geo */ \"(ssr)/./node_modules/d3-geo/src/distance.js\");\n/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-geo */ \"(ssr)/./node_modules/d3-geo/src/interpolate.js\");\n\n\n\n\nfunction _arrayLikeToArray(r, a) {\n  (null == a || a > r.length) && (a = r.length);\n  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];\n  return n;\n}\nfunction _arrayWithHoles(r) {\n  if (Array.isArray(r)) return r;\n}\nfunction _assertThisInitialized(e) {\n  if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  return e;\n}\nfunction _callSuper(t, o, e) {\n  return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, [], _getPrototypeOf(t).constructor) : o.apply(t, e));\n}\nfunction _classCallCheck(a, n) {\n  if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\");\n}\nfunction _createClass(e, r, t) {\n  return Object.defineProperty(e, \"prototype\", {\n    writable: !1\n  }), e;\n}\nfunction _createForOfIteratorHelper(r, e) {\n  var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n  if (!t) {\n    if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e) {\n      t && (r = t);\n      var n = 0,\n        F = function () {};\n      return {\n        s: F,\n        n: function () {\n          return n >= r.length ? {\n            done: !0\n          } : {\n            done: !1,\n            value: r[n++]\n          };\n        },\n        e: function (r) {\n          throw r;\n        },\n        f: F\n      };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  var o,\n    a = !0,\n    u = !1;\n  return {\n    s: function () {\n      t = t.call(r);\n    },\n    n: function () {\n      var r = t.next();\n      return a = r.done, r;\n    },\n    e: function (r) {\n      u = !0, o = r;\n    },\n    f: function () {\n      try {\n        a || null == t.return || t.return();\n      } finally {\n        if (u) throw o;\n      }\n    }\n  };\n}\nfunction _getPrototypeOf(t) {\n  return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {\n    return t.__proto__ || Object.getPrototypeOf(t);\n  }, _getPrototypeOf(t);\n}\nfunction _inherits(t, e) {\n  if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\");\n  t.prototype = Object.create(e && e.prototype, {\n    constructor: {\n      value: t,\n      writable: !0,\n      configurable: !0\n    }\n  }), Object.defineProperty(t, \"prototype\", {\n    writable: !1\n  }), e && _setPrototypeOf(t, e);\n}\nfunction _isNativeReflectConstruct() {\n  try {\n    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n  } catch (t) {}\n  return (_isNativeReflectConstruct = function () {\n    return !!t;\n  })();\n}\nfunction _iterableToArrayLimit(r, l) {\n  var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n  if (null != t) {\n    var e,\n      n,\n      i,\n      u,\n      a = [],\n      f = !0,\n      o = !1;\n    try {\n      if (i = (t = t.call(r)).next, 0 === l) {\n        if (Object(t) !== t) return;\n        f = !1;\n      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n    } catch (r) {\n      o = !0, n = r;\n    } finally {\n      try {\n        if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;\n      } finally {\n        if (o) throw n;\n      }\n    }\n    return a;\n  }\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _possibleConstructorReturn(t, e) {\n  if (e && (\"object\" == typeof e || \"function\" == typeof e)) return e;\n  if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\");\n  return _assertThisInitialized(t);\n}\nfunction _setPrototypeOf(t, e) {\n  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {\n    return t.__proto__ = e, t;\n  }, _setPrototypeOf(t, e);\n}\nfunction _slicedToArray(r, e) {\n  return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();\n}\nfunction _unsupportedIterableToArray(r, a) {\n  if (r) {\n    if (\"string\" == typeof r) return _arrayLikeToArray(r, a);\n    var t = {}.toString.call(r).slice(8, -1);\n    return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;\n  }\n}\n\nvar interpolateLine = function interpolateLine() {\n  var lineCoords = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  var maxDegDistance = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  var result = [];\n  var prevPnt = null;\n  lineCoords.forEach(function (pnt) {\n    if (prevPnt) {\n      var dist = (0,d3_geo__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(pnt, prevPnt) * 180 / Math.PI;\n      if (dist > maxDegDistance) {\n        var interpol = (0,d3_geo__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(prevPnt, pnt);\n        var tStep = 1 / Math.ceil(dist / maxDegDistance);\n        var t = tStep;\n        while (t < 1) {\n          result.push(interpol(t));\n          t += tStep;\n        }\n      }\n    }\n    result.push(prevPnt = pnt);\n  });\n  return result;\n};\n\nvar THREE = typeof window !== 'undefined' && window.THREE ? window.THREE // Prefer consumption from global THREE, if exists\n: {\n  BufferGeometry: three__WEBPACK_IMPORTED_MODULE_3__.BufferGeometry,\n  Float32BufferAttribute: three__WEBPACK_IMPORTED_MODULE_3__.Float32BufferAttribute\n};\n\n// support both modes for backwards threejs compatibility\nvar setAttributeFn = new THREE.BufferGeometry().setAttribute ? 'setAttribute' : 'addAttribute';\nvar GeoJsonGeometry = /*#__PURE__*/function (_THREE$BufferGeometry) {\n  function GeoJsonGeometry(geoJson) {\n    var _this;\n    var radius = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    var resolution = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 5;\n    _classCallCheck(this, GeoJsonGeometry);\n    _this = _callSuper(this, GeoJsonGeometry);\n    _this.type = 'GeoJsonGeometry';\n    _this.parameters = {\n      geoJson: geoJson,\n      radius: radius,\n      resolution: resolution\n    };\n\n    // process various geometry types\n    var groups = ({\n      Point: genPoint,\n      MultiPoint: genMultiPoint,\n      LineString: genLineString,\n      MultiLineString: genMultiLineString,\n      Polygon: genPolygon,\n      MultiPolygon: genMultiPolygon\n    }[geoJson.type] || function () {\n      return [];\n    })(geoJson.coordinates, radius);\n\n    // concat groups\n    var indices = [],\n      vertices = [];\n    var groupCnt = 0;\n    groups.forEach(function (newG) {\n      var prevIndCnt = indices.length;\n      concatGroup({\n        indices: indices,\n        vertices: vertices\n      }, newG);\n      _this.addGroup(prevIndCnt, indices.length - prevIndCnt, groupCnt++);\n    });\n\n    // build geometry\n    indices.length && _this.setIndex(indices);\n    vertices.length && _this[setAttributeFn]('position', new THREE.Float32BufferAttribute(vertices, 3));\n\n    //\n\n    function genPoint(coords, r) {\n      var vertices = polar2Cartesian(coords[1], coords[0], r);\n      var indices = [];\n      return [{\n        vertices: vertices,\n        indices: indices\n      }];\n    }\n    function genMultiPoint(coords, r) {\n      var result = {\n        vertices: [],\n        indices: []\n      };\n      coords.map(function (c) {\n        return genPoint(c, r);\n      }).forEach(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 1),\n          newPnt = _ref2[0];\n        concatGroup(result, newPnt);\n      });\n      return [result];\n    }\n    function genLineString(coords, r) {\n      var coords3d = interpolateLine(coords, resolution).map(function (_ref3) {\n        var _ref4 = _slicedToArray(_ref3, 2),\n          lng = _ref4[0],\n          lat = _ref4[1];\n        return polar2Cartesian(lat, lng, r);\n      });\n      var _earcutFlatten = (0,earcut__WEBPACK_IMPORTED_MODULE_0__.flatten)([coords3d]),\n        vertices = _earcutFlatten.vertices;\n      var numPoints = Math.round(vertices.length / 3);\n      var indices = [];\n      for (var vIdx = 1; vIdx < numPoints; vIdx++) {\n        indices.push(vIdx - 1, vIdx);\n      }\n      return [{\n        vertices: vertices,\n        indices: indices\n      }];\n    }\n    function genMultiLineString(coords, r) {\n      var result = {\n        vertices: [],\n        indices: []\n      };\n      coords.map(function (c) {\n        return genLineString(c, r);\n      }).forEach(function (_ref5) {\n        var _ref6 = _slicedToArray(_ref5, 1),\n          newLine = _ref6[0];\n        concatGroup(result, newLine);\n      });\n      return [result];\n    }\n    function genPolygon(coords, r) {\n      var coords3d = coords.map(function (coordsSegment) {\n        return interpolateLine(coordsSegment, resolution).map(function (_ref7) {\n          var _ref8 = _slicedToArray(_ref7, 2),\n            lng = _ref8[0],\n            lat = _ref8[1];\n          return polar2Cartesian(lat, lng, r);\n        });\n      });\n\n      // Each point generates 3 vertice items (x,y,z).\n      var _earcutFlatten2 = (0,earcut__WEBPACK_IMPORTED_MODULE_0__.flatten)(coords3d),\n        vertices = _earcutFlatten2.vertices,\n        holes = _earcutFlatten2.holes;\n      var firstHoleIdx = holes[0] || Infinity;\n      var outerVertices = vertices.slice(0, firstHoleIdx * 3);\n      var holeVertices = vertices.slice(firstHoleIdx * 3);\n      var holesIdx = new Set(holes);\n      var numPoints = Math.round(vertices.length / 3);\n      var outerIndices = [],\n        holeIndices = [];\n      for (var vIdx = 1; vIdx < numPoints; vIdx++) {\n        if (!holesIdx.has(vIdx)) {\n          if (vIdx < firstHoleIdx) {\n            outerIndices.push(vIdx - 1, vIdx);\n          } else {\n            holeIndices.push(vIdx - 1 - firstHoleIdx, vIdx - firstHoleIdx);\n          }\n        }\n      }\n      var groups = [{\n        indices: outerIndices,\n        vertices: outerVertices\n      }];\n      if (holes.length) {\n        groups.push({\n          indices: holeIndices,\n          vertices: holeVertices\n        });\n      }\n      return groups;\n    }\n    function genMultiPolygon(coords, r) {\n      var outer = {\n        vertices: [],\n        indices: []\n      };\n      var holes = {\n        vertices: [],\n        indices: []\n      };\n      coords.map(function (c) {\n        return genPolygon(c, r);\n      }).forEach(function (_ref9) {\n        var _ref10 = _slicedToArray(_ref9, 2),\n          newOuter = _ref10[0],\n          newHoles = _ref10[1];\n        concatGroup(outer, newOuter);\n        newHoles && concatGroup(holes, newHoles);\n      });\n      var groups = [outer];\n      holes.vertices.length && groups.push(holes);\n      return groups;\n    }\n    return _this;\n  }\n  _inherits(GeoJsonGeometry, _THREE$BufferGeometry);\n  return _createClass(GeoJsonGeometry);\n}(THREE.BufferGeometry); //\nfunction concatGroup(main, extra) {\n  var prevVertCnt = Math.round(main.vertices.length / 3);\n  concatArr(main.vertices, extra.vertices);\n  concatArr(main.indices, extra.indices.map(function (ind) {\n    return ind + prevVertCnt;\n  }));\n}\nfunction concatArr(target, src) {\n  var _iterator = _createForOfIteratorHelper(src),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var e = _step.value;\n      target.push(e);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n}\nfunction polar2Cartesian(lat, lng) {\n  var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var phi = (90 - lat) * Math.PI / 180;\n  var theta = (90 - lng) * Math.PI / 180;\n  return [r * Math.sin(phi) * Math.cos(theta),\n  // x\n  r * Math.cos(phi),\n  // y\n  r * Math.sin(phi) * Math.sin(theta) // z\n  ];\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtZ2VvanNvbi1nZW9tZXRyeS9kaXN0L3RocmVlLWdlb2pzb24tZ2VvbWV0cnkubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQStEO0FBQzlCO0FBQ29COztBQUVyRDtBQUNBO0FBQ0EsZ0NBQWdDLE9BQU87QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLHlGQUF5RjtBQUN6RixJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLFlBQVksa0VBQWtFO0FBQ3RGLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGtEQUFXO0FBQzVCO0FBQ0EsdUJBQXVCLGtEQUFjO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsaURBQWM7QUFDaEMsMEJBQTBCLHlEQUFzQjtBQUNoRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsMkJBQTJCLCtDQUFPO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixrQkFBa0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTzs7QUFFUDtBQUNBLDRCQUE0QiwrQ0FBTztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsa0JBQWtCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0JBQXdCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw4QkFBOEI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTJCIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEFkbWluXFxHbG9iYWwtSG91c2UtQWN0aXZpdHlcXGdsb2JlXFxub2RlX21vZHVsZXNcXHRocmVlLWdlb2pzb24tZ2VvbWV0cnlcXGRpc3RcXHRocmVlLWdlb2pzb24tZ2VvbWV0cnkubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJ1ZmZlckdlb21ldHJ5LCBGbG9hdDMyQnVmZmVyQXR0cmlidXRlIH0gZnJvbSAndGhyZWUnO1xuaW1wb3J0IHsgZmxhdHRlbiB9IGZyb20gJ2VhcmN1dCc7XG5pbXBvcnQgeyBnZW9EaXN0YW5jZSwgZ2VvSW50ZXJwb2xhdGUgfSBmcm9tICdkMy1nZW8nO1xuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShyLCBhKSB7XG4gIChudWxsID09IGEgfHwgYSA+IHIubGVuZ3RoKSAmJiAoYSA9IHIubGVuZ3RoKTtcbiAgZm9yICh2YXIgZSA9IDAsIG4gPSBBcnJheShhKTsgZSA8IGE7IGUrKykgbltlXSA9IHJbZV07XG4gIHJldHVybiBuO1xufVxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKHIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkocikpIHJldHVybiByO1xufVxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChlKSB7XG4gIGlmICh2b2lkIDAgPT09IGUpIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgcmV0dXJuIGU7XG59XG5mdW5jdGlvbiBfY2FsbFN1cGVyKHQsIG8sIGUpIHtcbiAgcmV0dXJuIG8gPSBfZ2V0UHJvdG90eXBlT2YobyksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHQsIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSA/IFJlZmxlY3QuY29uc3RydWN0KG8sIFtdLCBfZ2V0UHJvdG90eXBlT2YodCkuY29uc3RydWN0b3IpIDogby5hcHBseSh0LCBlKSk7XG59XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soYSwgbikge1xuICBpZiAoIShhIGluc3RhbmNlb2YgbikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG59XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoZSwgciwgdCkge1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwicHJvdG90eXBlXCIsIHtcbiAgICB3cml0YWJsZTogITFcbiAgfSksIGU7XG59XG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihyLCBlKSB7XG4gIHZhciB0ID0gXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgU3ltYm9sICYmIHJbU3ltYm9sLml0ZXJhdG9yXSB8fCByW1wiQEBpdGVyYXRvclwiXTtcbiAgaWYgKCF0KSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocikgfHwgKHQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkocikpIHx8IGUpIHtcbiAgICAgIHQgJiYgKHIgPSB0KTtcbiAgICAgIHZhciBuID0gMCxcbiAgICAgICAgRiA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgczogRixcbiAgICAgICAgbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBuID49IHIubGVuZ3RoID8ge1xuICAgICAgICAgICAgZG9uZTogITBcbiAgICAgICAgICB9IDoge1xuICAgICAgICAgICAgZG9uZTogITEsXG4gICAgICAgICAgICB2YWx1ZTogcltuKytdXG4gICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZTogZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgICB0aHJvdyByO1xuICAgICAgICB9LFxuICAgICAgICBmOiBGXG4gICAgICB9O1xuICAgIH1cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG4gIH1cbiAgdmFyIG8sXG4gICAgYSA9ICEwLFxuICAgIHUgPSAhMTtcbiAgcmV0dXJuIHtcbiAgICBzOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0ID0gdC5jYWxsKHIpO1xuICAgIH0sXG4gICAgbjogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHIgPSB0Lm5leHQoKTtcbiAgICAgIHJldHVybiBhID0gci5kb25lLCByO1xuICAgIH0sXG4gICAgZTogZnVuY3Rpb24gKHIpIHtcbiAgICAgIHUgPSAhMCwgbyA9IHI7XG4gICAgfSxcbiAgICBmOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0cnkge1xuICAgICAgICBhIHx8IG51bGwgPT0gdC5yZXR1cm4gfHwgdC5yZXR1cm4oKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmICh1KSB0aHJvdyBvO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZih0KSB7XG4gIHJldHVybiBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gKHQpIHtcbiAgICByZXR1cm4gdC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKHQpO1xuICB9LCBfZ2V0UHJvdG90eXBlT2YodCk7XG59XG5mdW5jdGlvbiBfaW5oZXJpdHModCwgZSkge1xuICBpZiAoXCJmdW5jdGlvblwiICE9IHR5cGVvZiBlICYmIG51bGwgIT09IGUpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgdC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGUgJiYgZS5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHQsXG4gICAgICB3cml0YWJsZTogITAsXG4gICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgfVxuICB9KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIFwicHJvdG90eXBlXCIsIHtcbiAgICB3cml0YWJsZTogITFcbiAgfSksIGUgJiYgX3NldFByb3RvdHlwZU9mKHQsIGUpO1xufVxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgdCA9ICFCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7XG4gIH0gY2F0Y2ggKHQpIHt9XG4gIHJldHVybiAoX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gISF0O1xuICB9KSgpO1xufVxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KHIsIGwpIHtcbiAgdmFyIHQgPSBudWxsID09IHIgPyBudWxsIDogXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgU3ltYm9sICYmIHJbU3ltYm9sLml0ZXJhdG9yXSB8fCByW1wiQEBpdGVyYXRvclwiXTtcbiAgaWYgKG51bGwgIT0gdCkge1xuICAgIHZhciBlLFxuICAgICAgbixcbiAgICAgIGksXG4gICAgICB1LFxuICAgICAgYSA9IFtdLFxuICAgICAgZiA9ICEwLFxuICAgICAgbyA9ICExO1xuICAgIHRyeSB7XG4gICAgICBpZiAoaSA9ICh0ID0gdC5jYWxsKHIpKS5uZXh0LCAwID09PSBsKSB7XG4gICAgICAgIGlmIChPYmplY3QodCkgIT09IHQpIHJldHVybjtcbiAgICAgICAgZiA9ICExO1xuICAgICAgfSBlbHNlIGZvciAoOyAhKGYgPSAoZSA9IGkuY2FsbCh0KSkuZG9uZSkgJiYgKGEucHVzaChlLnZhbHVlKSwgYS5sZW5ndGggIT09IGwpOyBmID0gITApO1xuICAgIH0gY2F0Y2ggKHIpIHtcbiAgICAgIG8gPSAhMCwgbiA9IHI7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghZiAmJiBudWxsICE9IHQucmV0dXJuICYmICh1ID0gdC5yZXR1cm4oKSwgT2JqZWN0KHUpICE9PSB1KSkgcmV0dXJuO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKG8pIHRocm93IG47XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhO1xuICB9XG59XG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odCwgZSkge1xuICBpZiAoZSAmJiAoXCJvYmplY3RcIiA9PSB0eXBlb2YgZSB8fCBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGUpKSByZXR1cm4gZTtcbiAgaWYgKHZvaWQgMCAhPT0gZSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpO1xuICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZCh0KTtcbn1cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZih0LCBlKSB7XG4gIHJldHVybiBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gKHQsIGUpIHtcbiAgICByZXR1cm4gdC5fX3Byb3RvX18gPSBlLCB0O1xuICB9LCBfc2V0UHJvdG90eXBlT2YodCwgZSk7XG59XG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShyLCBlKSB7XG4gIHJldHVybiBfYXJyYXlXaXRoSG9sZXMocikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KHIsIGUpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShyLCBlKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7XG59XG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkociwgYSkge1xuICBpZiAocikge1xuICAgIGlmIChcInN0cmluZ1wiID09IHR5cGVvZiByKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkociwgYSk7XG4gICAgdmFyIHQgPSB7fS50b1N0cmluZy5jYWxsKHIpLnNsaWNlKDgsIC0xKTtcbiAgICByZXR1cm4gXCJPYmplY3RcIiA9PT0gdCAmJiByLmNvbnN0cnVjdG9yICYmICh0ID0gci5jb25zdHJ1Y3Rvci5uYW1lKSwgXCJNYXBcIiA9PT0gdCB8fCBcIlNldFwiID09PSB0ID8gQXJyYXkuZnJvbShyKSA6IFwiQXJndW1lbnRzXCIgPT09IHQgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QodCkgPyBfYXJyYXlMaWtlVG9BcnJheShyLCBhKSA6IHZvaWQgMDtcbiAgfVxufVxuXG52YXIgaW50ZXJwb2xhdGVMaW5lID0gZnVuY3Rpb24gaW50ZXJwb2xhdGVMaW5lKCkge1xuICB2YXIgbGluZUNvb3JkcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogW107XG4gIHZhciBtYXhEZWdEaXN0YW5jZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMTtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIgcHJldlBudCA9IG51bGw7XG4gIGxpbmVDb29yZHMuZm9yRWFjaChmdW5jdGlvbiAocG50KSB7XG4gICAgaWYgKHByZXZQbnQpIHtcbiAgICAgIHZhciBkaXN0ID0gZ2VvRGlzdGFuY2UocG50LCBwcmV2UG50KSAqIDE4MCAvIE1hdGguUEk7XG4gICAgICBpZiAoZGlzdCA+IG1heERlZ0Rpc3RhbmNlKSB7XG4gICAgICAgIHZhciBpbnRlcnBvbCA9IGdlb0ludGVycG9sYXRlKHByZXZQbnQsIHBudCk7XG4gICAgICAgIHZhciB0U3RlcCA9IDEgLyBNYXRoLmNlaWwoZGlzdCAvIG1heERlZ0Rpc3RhbmNlKTtcbiAgICAgICAgdmFyIHQgPSB0U3RlcDtcbiAgICAgICAgd2hpbGUgKHQgPCAxKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goaW50ZXJwb2wodCkpO1xuICAgICAgICAgIHQgKz0gdFN0ZXA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0LnB1c2gocHJldlBudCA9IHBudCk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxudmFyIFRIUkVFID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LlRIUkVFID8gd2luZG93LlRIUkVFIC8vIFByZWZlciBjb25zdW1wdGlvbiBmcm9tIGdsb2JhbCBUSFJFRSwgaWYgZXhpc3RzXG46IHtcbiAgQnVmZmVyR2VvbWV0cnk6IEJ1ZmZlckdlb21ldHJ5LFxuICBGbG9hdDMyQnVmZmVyQXR0cmlidXRlOiBGbG9hdDMyQnVmZmVyQXR0cmlidXRlXG59O1xuXG4vLyBzdXBwb3J0IGJvdGggbW9kZXMgZm9yIGJhY2t3YXJkcyB0aHJlZWpzIGNvbXBhdGliaWxpdHlcbnZhciBzZXRBdHRyaWJ1dGVGbiA9IG5ldyBUSFJFRS5CdWZmZXJHZW9tZXRyeSgpLnNldEF0dHJpYnV0ZSA/ICdzZXRBdHRyaWJ1dGUnIDogJ2FkZEF0dHJpYnV0ZSc7XG52YXIgR2VvSnNvbkdlb21ldHJ5ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfVEhSRUUkQnVmZmVyR2VvbWV0cnkpIHtcbiAgZnVuY3Rpb24gR2VvSnNvbkdlb21ldHJ5KGdlb0pzb24pIHtcbiAgICB2YXIgX3RoaXM7XG4gICAgdmFyIHJhZGl1cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMTtcbiAgICB2YXIgcmVzb2x1dGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogNTtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgR2VvSnNvbkdlb21ldHJ5KTtcbiAgICBfdGhpcyA9IF9jYWxsU3VwZXIodGhpcywgR2VvSnNvbkdlb21ldHJ5KTtcbiAgICBfdGhpcy50eXBlID0gJ0dlb0pzb25HZW9tZXRyeSc7XG4gICAgX3RoaXMucGFyYW1ldGVycyA9IHtcbiAgICAgIGdlb0pzb246IGdlb0pzb24sXG4gICAgICByYWRpdXM6IHJhZGl1cyxcbiAgICAgIHJlc29sdXRpb246IHJlc29sdXRpb25cbiAgICB9O1xuXG4gICAgLy8gcHJvY2VzcyB2YXJpb3VzIGdlb21ldHJ5IHR5cGVzXG4gICAgdmFyIGdyb3VwcyA9ICh7XG4gICAgICBQb2ludDogZ2VuUG9pbnQsXG4gICAgICBNdWx0aVBvaW50OiBnZW5NdWx0aVBvaW50LFxuICAgICAgTGluZVN0cmluZzogZ2VuTGluZVN0cmluZyxcbiAgICAgIE11bHRpTGluZVN0cmluZzogZ2VuTXVsdGlMaW5lU3RyaW5nLFxuICAgICAgUG9seWdvbjogZ2VuUG9seWdvbixcbiAgICAgIE11bHRpUG9seWdvbjogZ2VuTXVsdGlQb2x5Z29uXG4gICAgfVtnZW9Kc29uLnR5cGVdIHx8IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9KShnZW9Kc29uLmNvb3JkaW5hdGVzLCByYWRpdXMpO1xuXG4gICAgLy8gY29uY2F0IGdyb3Vwc1xuICAgIHZhciBpbmRpY2VzID0gW10sXG4gICAgICB2ZXJ0aWNlcyA9IFtdO1xuICAgIHZhciBncm91cENudCA9IDA7XG4gICAgZ3JvdXBzLmZvckVhY2goZnVuY3Rpb24gKG5ld0cpIHtcbiAgICAgIHZhciBwcmV2SW5kQ250ID0gaW5kaWNlcy5sZW5ndGg7XG4gICAgICBjb25jYXRHcm91cCh7XG4gICAgICAgIGluZGljZXM6IGluZGljZXMsXG4gICAgICAgIHZlcnRpY2VzOiB2ZXJ0aWNlc1xuICAgICAgfSwgbmV3Ryk7XG4gICAgICBfdGhpcy5hZGRHcm91cChwcmV2SW5kQ250LCBpbmRpY2VzLmxlbmd0aCAtIHByZXZJbmRDbnQsIGdyb3VwQ250KyspO1xuICAgIH0pO1xuXG4gICAgLy8gYnVpbGQgZ2VvbWV0cnlcbiAgICBpbmRpY2VzLmxlbmd0aCAmJiBfdGhpcy5zZXRJbmRleChpbmRpY2VzKTtcbiAgICB2ZXJ0aWNlcy5sZW5ndGggJiYgX3RoaXNbc2V0QXR0cmlidXRlRm5dKCdwb3NpdGlvbicsIG5ldyBUSFJFRS5GbG9hdDMyQnVmZmVyQXR0cmlidXRlKHZlcnRpY2VzLCAzKSk7XG5cbiAgICAvL1xuXG4gICAgZnVuY3Rpb24gZ2VuUG9pbnQoY29vcmRzLCByKSB7XG4gICAgICB2YXIgdmVydGljZXMgPSBwb2xhcjJDYXJ0ZXNpYW4oY29vcmRzWzFdLCBjb29yZHNbMF0sIHIpO1xuICAgICAgdmFyIGluZGljZXMgPSBbXTtcbiAgICAgIHJldHVybiBbe1xuICAgICAgICB2ZXJ0aWNlczogdmVydGljZXMsXG4gICAgICAgIGluZGljZXM6IGluZGljZXNcbiAgICAgIH1dO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZW5NdWx0aVBvaW50KGNvb3Jkcywgcikge1xuICAgICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgdmVydGljZXM6IFtdLFxuICAgICAgICBpbmRpY2VzOiBbXVxuICAgICAgfTtcbiAgICAgIGNvb3Jkcy5tYXAoZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIGdlblBvaW50KGMsIHIpO1xuICAgICAgfSkuZm9yRWFjaChmdW5jdGlvbiAoX3JlZikge1xuICAgICAgICB2YXIgX3JlZjIgPSBfc2xpY2VkVG9BcnJheShfcmVmLCAxKSxcbiAgICAgICAgICBuZXdQbnQgPSBfcmVmMlswXTtcbiAgICAgICAgY29uY2F0R3JvdXAocmVzdWx0LCBuZXdQbnQpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gW3Jlc3VsdF07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdlbkxpbmVTdHJpbmcoY29vcmRzLCByKSB7XG4gICAgICB2YXIgY29vcmRzM2QgPSBpbnRlcnBvbGF0ZUxpbmUoY29vcmRzLCByZXNvbHV0aW9uKS5tYXAoZnVuY3Rpb24gKF9yZWYzKSB7XG4gICAgICAgIHZhciBfcmVmNCA9IF9zbGljZWRUb0FycmF5KF9yZWYzLCAyKSxcbiAgICAgICAgICBsbmcgPSBfcmVmNFswXSxcbiAgICAgICAgICBsYXQgPSBfcmVmNFsxXTtcbiAgICAgICAgcmV0dXJuIHBvbGFyMkNhcnRlc2lhbihsYXQsIGxuZywgcik7XG4gICAgICB9KTtcbiAgICAgIHZhciBfZWFyY3V0RmxhdHRlbiA9IGZsYXR0ZW4oW2Nvb3JkczNkXSksXG4gICAgICAgIHZlcnRpY2VzID0gX2VhcmN1dEZsYXR0ZW4udmVydGljZXM7XG4gICAgICB2YXIgbnVtUG9pbnRzID0gTWF0aC5yb3VuZCh2ZXJ0aWNlcy5sZW5ndGggLyAzKTtcbiAgICAgIHZhciBpbmRpY2VzID0gW107XG4gICAgICBmb3IgKHZhciB2SWR4ID0gMTsgdklkeCA8IG51bVBvaW50czsgdklkeCsrKSB7XG4gICAgICAgIGluZGljZXMucHVzaCh2SWR4IC0gMSwgdklkeCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gW3tcbiAgICAgICAgdmVydGljZXM6IHZlcnRpY2VzLFxuICAgICAgICBpbmRpY2VzOiBpbmRpY2VzXG4gICAgICB9XTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2VuTXVsdGlMaW5lU3RyaW5nKGNvb3Jkcywgcikge1xuICAgICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgdmVydGljZXM6IFtdLFxuICAgICAgICBpbmRpY2VzOiBbXVxuICAgICAgfTtcbiAgICAgIGNvb3Jkcy5tYXAoZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIGdlbkxpbmVTdHJpbmcoYywgcik7XG4gICAgICB9KS5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmNSkge1xuICAgICAgICB2YXIgX3JlZjYgPSBfc2xpY2VkVG9BcnJheShfcmVmNSwgMSksXG4gICAgICAgICAgbmV3TGluZSA9IF9yZWY2WzBdO1xuICAgICAgICBjb25jYXRHcm91cChyZXN1bHQsIG5ld0xpbmUpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gW3Jlc3VsdF07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdlblBvbHlnb24oY29vcmRzLCByKSB7XG4gICAgICB2YXIgY29vcmRzM2QgPSBjb29yZHMubWFwKGZ1bmN0aW9uIChjb29yZHNTZWdtZW50KSB7XG4gICAgICAgIHJldHVybiBpbnRlcnBvbGF0ZUxpbmUoY29vcmRzU2VnbWVudCwgcmVzb2x1dGlvbikubWFwKGZ1bmN0aW9uIChfcmVmNykge1xuICAgICAgICAgIHZhciBfcmVmOCA9IF9zbGljZWRUb0FycmF5KF9yZWY3LCAyKSxcbiAgICAgICAgICAgIGxuZyA9IF9yZWY4WzBdLFxuICAgICAgICAgICAgbGF0ID0gX3JlZjhbMV07XG4gICAgICAgICAgcmV0dXJuIHBvbGFyMkNhcnRlc2lhbihsYXQsIGxuZywgcik7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIEVhY2ggcG9pbnQgZ2VuZXJhdGVzIDMgdmVydGljZSBpdGVtcyAoeCx5LHopLlxuICAgICAgdmFyIF9lYXJjdXRGbGF0dGVuMiA9IGZsYXR0ZW4oY29vcmRzM2QpLFxuICAgICAgICB2ZXJ0aWNlcyA9IF9lYXJjdXRGbGF0dGVuMi52ZXJ0aWNlcyxcbiAgICAgICAgaG9sZXMgPSBfZWFyY3V0RmxhdHRlbjIuaG9sZXM7XG4gICAgICB2YXIgZmlyc3RIb2xlSWR4ID0gaG9sZXNbMF0gfHwgSW5maW5pdHk7XG4gICAgICB2YXIgb3V0ZXJWZXJ0aWNlcyA9IHZlcnRpY2VzLnNsaWNlKDAsIGZpcnN0SG9sZUlkeCAqIDMpO1xuICAgICAgdmFyIGhvbGVWZXJ0aWNlcyA9IHZlcnRpY2VzLnNsaWNlKGZpcnN0SG9sZUlkeCAqIDMpO1xuICAgICAgdmFyIGhvbGVzSWR4ID0gbmV3IFNldChob2xlcyk7XG4gICAgICB2YXIgbnVtUG9pbnRzID0gTWF0aC5yb3VuZCh2ZXJ0aWNlcy5sZW5ndGggLyAzKTtcbiAgICAgIHZhciBvdXRlckluZGljZXMgPSBbXSxcbiAgICAgICAgaG9sZUluZGljZXMgPSBbXTtcbiAgICAgIGZvciAodmFyIHZJZHggPSAxOyB2SWR4IDwgbnVtUG9pbnRzOyB2SWR4KyspIHtcbiAgICAgICAgaWYgKCFob2xlc0lkeC5oYXModklkeCkpIHtcbiAgICAgICAgICBpZiAodklkeCA8IGZpcnN0SG9sZUlkeCkge1xuICAgICAgICAgICAgb3V0ZXJJbmRpY2VzLnB1c2godklkeCAtIDEsIHZJZHgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBob2xlSW5kaWNlcy5wdXNoKHZJZHggLSAxIC0gZmlyc3RIb2xlSWR4LCB2SWR4IC0gZmlyc3RIb2xlSWR4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBncm91cHMgPSBbe1xuICAgICAgICBpbmRpY2VzOiBvdXRlckluZGljZXMsXG4gICAgICAgIHZlcnRpY2VzOiBvdXRlclZlcnRpY2VzXG4gICAgICB9XTtcbiAgICAgIGlmIChob2xlcy5sZW5ndGgpIHtcbiAgICAgICAgZ3JvdXBzLnB1c2goe1xuICAgICAgICAgIGluZGljZXM6IGhvbGVJbmRpY2VzLFxuICAgICAgICAgIHZlcnRpY2VzOiBob2xlVmVydGljZXNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZ3JvdXBzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZW5NdWx0aVBvbHlnb24oY29vcmRzLCByKSB7XG4gICAgICB2YXIgb3V0ZXIgPSB7XG4gICAgICAgIHZlcnRpY2VzOiBbXSxcbiAgICAgICAgaW5kaWNlczogW11cbiAgICAgIH07XG4gICAgICB2YXIgaG9sZXMgPSB7XG4gICAgICAgIHZlcnRpY2VzOiBbXSxcbiAgICAgICAgaW5kaWNlczogW11cbiAgICAgIH07XG4gICAgICBjb29yZHMubWFwKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiBnZW5Qb2x5Z29uKGMsIHIpO1xuICAgICAgfSkuZm9yRWFjaChmdW5jdGlvbiAoX3JlZjkpIHtcbiAgICAgICAgdmFyIF9yZWYxMCA9IF9zbGljZWRUb0FycmF5KF9yZWY5LCAyKSxcbiAgICAgICAgICBuZXdPdXRlciA9IF9yZWYxMFswXSxcbiAgICAgICAgICBuZXdIb2xlcyA9IF9yZWYxMFsxXTtcbiAgICAgICAgY29uY2F0R3JvdXAob3V0ZXIsIG5ld091dGVyKTtcbiAgICAgICAgbmV3SG9sZXMgJiYgY29uY2F0R3JvdXAoaG9sZXMsIG5ld0hvbGVzKTtcbiAgICAgIH0pO1xuICAgICAgdmFyIGdyb3VwcyA9IFtvdXRlcl07XG4gICAgICBob2xlcy52ZXJ0aWNlcy5sZW5ndGggJiYgZ3JvdXBzLnB1c2goaG9sZXMpO1xuICAgICAgcmV0dXJuIGdyb3VwcztcbiAgICB9XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIF9pbmhlcml0cyhHZW9Kc29uR2VvbWV0cnksIF9USFJFRSRCdWZmZXJHZW9tZXRyeSk7XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoR2VvSnNvbkdlb21ldHJ5KTtcbn0oVEhSRUUuQnVmZmVyR2VvbWV0cnkpOyAvL1xuZnVuY3Rpb24gY29uY2F0R3JvdXAobWFpbiwgZXh0cmEpIHtcbiAgdmFyIHByZXZWZXJ0Q250ID0gTWF0aC5yb3VuZChtYWluLnZlcnRpY2VzLmxlbmd0aCAvIDMpO1xuICBjb25jYXRBcnIobWFpbi52ZXJ0aWNlcywgZXh0cmEudmVydGljZXMpO1xuICBjb25jYXRBcnIobWFpbi5pbmRpY2VzLCBleHRyYS5pbmRpY2VzLm1hcChmdW5jdGlvbiAoaW5kKSB7XG4gICAgcmV0dXJuIGluZCArIHByZXZWZXJ0Q250O1xuICB9KSk7XG59XG5mdW5jdGlvbiBjb25jYXRBcnIodGFyZ2V0LCBzcmMpIHtcbiAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHNyYyksXG4gICAgX3N0ZXA7XG4gIHRyeSB7XG4gICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgIHZhciBlID0gX3N0ZXAudmFsdWU7XG4gICAgICB0YXJnZXQucHVzaChlKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9pdGVyYXRvci5lKGVycik7XG4gIH0gZmluYWxseSB7XG4gICAgX2l0ZXJhdG9yLmYoKTtcbiAgfVxufVxuZnVuY3Rpb24gcG9sYXIyQ2FydGVzaWFuKGxhdCwgbG5nKSB7XG4gIHZhciByID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAwO1xuICB2YXIgcGhpID0gKDkwIC0gbGF0KSAqIE1hdGguUEkgLyAxODA7XG4gIHZhciB0aGV0YSA9ICg5MCAtIGxuZykgKiBNYXRoLlBJIC8gMTgwO1xuICByZXR1cm4gW3IgKiBNYXRoLnNpbihwaGkpICogTWF0aC5jb3ModGhldGEpLFxuICAvLyB4XG4gIHIgKiBNYXRoLmNvcyhwaGkpLFxuICAvLyB5XG4gIHIgKiBNYXRoLnNpbihwaGkpICogTWF0aC5zaW4odGhldGEpIC8vIHpcbiAgXTtcbn1cblxuZXhwb3J0IHsgR2VvSnNvbkdlb21ldHJ5IH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-geojson-geometry/dist/three-geojson-geometry.mjs\n");

/***/ })

};
;